---
title: "Clustering Smoke Test"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Clustering Smoke Test}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette runs a real data smoke test of the clustering functionality using DIAMOND reciprocal best hits.

## Setup

```{r setup}
library(paneffectR)
library(dplyr)
```

## Load Sample Data

We'll use three small P. destructor assemblies from the sample data:

```{r load-data}
# Use sample data directory - try both paths for vignette vs interactive use
sample_dir <- if (dir.exists("sample_data/reformatted")) {
  "sample_data/reformatted"
} else if (dir.exists("../sample_data/reformatted")) {
  "../sample_data/reformatted"
} else {
  stop("Sample data not found")
}

# Load just the 3 smallest assemblies for quick testing
fasta_files <- list.files(sample_dir, pattern = "\\.faa$", full.names = TRUE)
file_sizes <- file.info(fasta_files)$size
smallest_files <- fasta_files[order(file_sizes)][1:3]

cat("Using assemblies:\n")
for (f in smallest_files) {
  cat(" -", basename(f), sprintf("(%.1f MB)\n", file.info(f)$size / 1e6))
}
```

```{r load-proteins}
# Load each assembly individually and combine
protein_sets <- lapply(smallest_files, function(fasta_path) {
  assembly_name <- tools::file_path_sans_ext(basename(fasta_path))
  proteins <- load_fasta(fasta_path)
  new_protein_set(assembly_name, proteins)
})

proteins <- new_protein_collection(protein_sets)
proteins
```

## Run Clustering

Now we'll cluster proteins using DIAMOND reciprocal best hits:
```{r cluster, message=FALSE}
# Find DIAMOND in project environment - try multiple paths
diamond_candidates <- c(
  "this_project_env/bin/diamond",
  "../this_project_env/bin/diamond",
  "./this_project_env/bin/diamond"
)
diamond_path <- NULL
for (p in diamond_candidates) {
  if (file.exists(p)) {
    diamond_path <- p
    break
  }
}
if (is.null(diamond_path)) {
  diamond_path <- Sys.which("diamond")
}

if (!nzchar(diamond_path)) {
  stop("DIAMOND not found. Install with: mamba install -c bioconda diamond")
}

cat("Using DIAMOND at:", diamond_path, "\n\n")

# Run clustering with default parameters
result <- cluster_proteins(
  proteins,
  method = "diamond_rbh",
  mode = "fast",
  min_identity = 30,
  min_coverage = 50,
  tool_path = diamond_path
)

result
```

## Examine Results

### Orthogroup Summary

```{r orthogroup-summary}
# Basic stats
cat("Total orthogroups:", result$stats$n_orthogroups, "\n")
cat("Total singletons:", result$stats$n_singletons, "\n")
cat("Total proteins clustered:", nrow(result$orthogroups), "\n")

# Parameters used
cat("\nClustering parameters:\n")
str(result$parameters)
```

### Orthogroup Size Distribution

With reciprocal best hits (RBH), orthogroups are pairs - each orthogroup contains exactly 2 proteins that are each other's best hit. To get larger orthogroups, we would use single-linkage clustering or OrthoFinder.

```{r size-distribution}
# Count proteins per orthogroup
og_sizes <- result$orthogroups |>
  count(orthogroup_id, name = "n_proteins") |>
  arrange(desc(n_proteins))

cat("Orthogroup size distribution:\n")
summary(og_sizes$n_proteins)

# Top 10 largest orthogroups
cat("\nTop 10 largest orthogroups:\n")
head(og_sizes, 10)
```

### Assembly Coverage

```{r assembly-coverage}
# How many orthogroups does each assembly contribute to?
assembly_coverage <- result$orthogroups |>
  group_by(assembly) |>
  summarise(
    n_proteins_clustered = n(),
    n_orthogroups = n_distinct(orthogroup_id),
    .groups = "drop"
  )

cat("Assembly coverage:\n")
print(assembly_coverage)
```

### Multi-Assembly Orthogroups

```{r multi-assembly}
# Find orthogroups present in multiple assemblies (the interesting ones!)
multi_assembly_ogs <- result$orthogroups |>
  group_by(orthogroup_id) |>
  summarise(
    n_assemblies = n_distinct(assembly),
    n_proteins = n(),
    assemblies = paste(unique(assembly), collapse = ", "),
    .groups = "drop"
  ) |>
  filter(n_assemblies > 1) |>
  arrange(desc(n_assemblies), desc(n_proteins))

cat("Orthogroups shared across assemblies:", nrow(multi_assembly_ogs), "\n")
cat("Orthogroups in all 3 assemblies:", sum(multi_assembly_ogs$n_assemblies == 3), "\n")
cat("Orthogroups in 2 assemblies:", sum(multi_assembly_ogs$n_assemblies == 2), "\n")
```

### Singletons

```{r singletons}
# Proteins not assigned to any orthogroup
cat("Singletons by assembly:\n")
result$singletons |>
  count(assembly, name = "n_singletons") |>
  print()
```

## Parameter Comparison (Optional)

The following tests stricter parameters and thorough mode. They are set to `eval=FALSE` by default to speed up vignette rendering - set `eval=TRUE` to run them.

```{r cluster-strict, message=FALSE, eval=FALSE}
# Test with stricter identity/coverage thresholds
result_strict <- cluster_proteins(
 proteins,
  method = "diamond_rbh",
  mode = "fast",
  min_identity = 70,
  min_coverage = 80,
  tool_path = diamond_path
)

cat("With stricter parameters (70% identity, 80% coverage):\n")
result_strict

cat("\nComparison:\n")
cat("  Default params: ", result$stats$n_orthogroups, " orthogroups, ",
    result$stats$n_singletons, " singletons\n", sep = "")
cat("  Strict params:  ", result_strict$stats$n_orthogroups, " orthogroups, ",
    result_strict$stats$n_singletons, " singletons\n", sep = "")
```

```{r cluster-thorough, message=FALSE, eval=FALSE}
# Test thorough mode (more sensitive, slower)
result_thorough <- cluster_proteins(
  proteins,
  method = "diamond_rbh",
  mode = "thorough",
  min_identity = 30,
  min_coverage = 50,
  tool_path = diamond_path
)

cat("Thorough mode results:\n")
result_thorough
cat("\nMode recorded in parameters:", result_thorough$parameters$mode, "\n")
```

## Session Info

```{r session-info}
sessionInfo()
```
