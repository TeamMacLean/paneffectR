---
title: "Getting Started with paneffectR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with paneffectR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

paneffectR helps you compare proteins across multiple genome assemblies. The typical workflow is:
1. **Load** protein sequences from FASTA files
2. **Cluster** proteins into orthogroups (groups of equivalent proteins)
3. **Build** a presence/absence matrix
4. **Visualize** the results

This vignette walks through each step using example data included with the package.

## Setup

```{r setup}
library(paneffectR)
```

## Step 1: Load Protein Data

The main entry point is `load_proteins()`, which discovers and loads all FASTA files from a directory:

```{r load-data}
# Get path to test data included with the package
testdata_dir <- system.file("testdata", package = "paneffectR")

# Load all assemblies (FASTAs and scores)
proteins <- load_proteins(
  fasta_dir = testdata_dir,
  score_dir = testdata_dir,
  pattern = "*.faa"
)
proteins
```

The result is a `protein_collection` containing all assemblies. You can see:

- How many assemblies were loaded
- How many proteins in each
- Whether effector scores are present

### Exploring the Data

Each assembly is stored as a `protein_set`. Access individual assemblies by name:

```{r explore-data}
# Access one assembly
ps <- proteins$assemblies[["assembly1"]]
ps

# The proteins are stored as a tibble
head(ps$proteins[, c("protein_id", "sequence", "custom_score", "score_rank")])
```

## Step 2: Cluster Proteins

Now we group proteins from different assemblies into **orthogroups** - sets of proteins that are likely the same gene/function across assemblies.

```{r cluster, eval=FALSE}
# Cluster using DIAMOND reciprocal best hits
clusters <- cluster_proteins(proteins, method = "diamond_rbh")
clusters
```

**Note:** Clustering requires DIAMOND to be installed. If you don't have DIAMOND, you can skip this step and use the pre-computed clusters included with the package for the visualization examples.

For this vignette, we'll load pre-computed results:

```{r load-clusters}
# Load pre-computed visual test data
visual_dir <- system.file("testdata", "visual", package = "paneffectR")
clusters <- readRDS(file.path(visual_dir, "clusters_visual.rds"))
clusters
```

### Understanding Orthogroups

An orthogroup result contains:

- **orthogroups**: Which proteins belong to which group
- **singletons**: Proteins not assigned to any group (unique to one assembly)
- **stats**: Summary statistics

```{r explore-clusters}
# See the orthogroup assignments
head(clusters$orthogroups)

# How many singletons?
n_singletons(clusters)

# Singletons by assembly
singletons_by_assembly(clusters)
```

## Step 3: Build Presence/Absence Matrix

Convert the orthogroups into a matrix where:

- **Rows** = orthogroups
- **Columns** = assemblies
- **Values** = presence (1) or absence (0)

```{r build-matrix}
# Build binary presence/absence matrix
pa <- build_pa_matrix(clusters, type = "binary")
pa

# View the raw matrix
pa$matrix[1:10, ]
```

### Including Singletons

By default, singletons (proteins unique to one assembly) are included as their own orthogroups:

```{r singletons}
# Without singletons
pa_no_single <- build_pa_matrix(clusters, type = "binary", exclude_singletons = TRUE)

# Compare dimensions
cat("With singletons:", nrow(pa$matrix), "orthogroups\n")
cat("Without singletons:", nrow(pa_no_single$matrix), "orthogroups\n")
```

## Step 4: Visualize

### Heatmap

The heatmap shows presence/absence patterns across all assemblies:

```{r heatmap}
ht <- plot_heatmap(pa)
ComplexHeatmap::draw(ht)
```

Customize with clustering and colors:

```{r heatmap-options}
ht <- plot_heatmap(
  pa,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  distance_method = "jaccard",
  color = c("white", "steelblue")
)
ComplexHeatmap::draw(ht)
```

### UpSet Plot

UpSet plots show which orthogroups are shared between assemblies:

```{r upset}
# Show intersections with at least 2 orthogroups
plot_upset(pa, min_size = 1)
```

### Assembly Dendrogram

Cluster assemblies by their shared orthogroup content:

```{r dendro}
plot_dendro(pa, distance_method = "jaccard")
```

## Working with Scores

If your data includes effector prediction scores (from omnieff), you can:

### Filter by Score

Only include high-confidence effector predictions:

```{r score-threshold, eval=FALSE}
# Build matrix with score threshold
pa_filtered <- build_pa_matrix(
  clusters,
  type = "binary",
  score_threshold = 5.0,  # Only include proteins with score >= 5
  proteins = proteins     # Need proteins to access scores
)
```

### Visualize Score Distributions

```{r scores}
# Score distributions across all assemblies
plot_scores(proteins)

# Faceted by assembly with threshold line
plot_scores(proteins, by_assembly = TRUE, threshold = 5.0)
```

## Summary

The core paneffectR workflow:

1. `load_proteins()` - Load FASTA files (and optional scores)
2. `cluster_proteins()` - Group proteins into orthogroups
3. `build_pa_matrix()` - Create presence/absence matrix
4. `plot_*()` - Visualize results

## Next Steps

- **[Effector Analysis](effector-analysis.html)** - Working with omnieff output and score filtering
- **[Pan-Genome Analysis](pan-genome.html)** - Analyzing core vs accessory proteins
- **[Algorithm Deep Dive](algorithms.html)** - Technical details on clustering methods
